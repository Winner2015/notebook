# 索引

数据库中的索引可以分为**聚集索引**（clustered index）和**辅助索引**（secondary index）。两者的底层实现都是B+树，即高度平衡的，叶子节点存放着所有数据。聚集索引与辅助索引的主要区别在于，叶子节点存放的是否为一整行的信息。

## 聚集索引

InnoDB中的表是索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。

由于实际的数据只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。

在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引对于主键的排序查找和范围查找非常快。

## 辅助索引

辅助索引的叶子节点不包含行记录的全部数据，而是包含了一个书签，用来告诉InnoDB哪里可以找到对应的行数据。

当通过辅助索引来查找数据时，InnoDB会遍历叶子节点获得指向主键索引，然后再通过主键索引找到一个完整的行记录。

## Fast Index Creation

MySQL5.5版本之前存在一个普遍被人诟病的问题是,MySQL对于索引的添加或删除这类的DDL操作过程为：

1. 首先创建一张新的临时表，表结构为通过命令alter table新定义的结构；
2. 把原表的数据导入临时表中；
3. 删除原表；
4. 把临时表重命名为原来的表。

临时表的创建路劲是通过参数tmpdir进行设置的，用户必须保证tmpdir有足够的空间可以存放临时表，否则会导致创建索引失败。

若用户要对一张大表进行索引的添加和删除操作，那么会需要很长的时间。更关键的是，若有大量事务需要访问正在被修改的表，这意味着数据库服务不可用。

InnoDB 1.0.x版本开始支持一种称为**fast index creation**的索引创建方式——简称**FIC**。

对于辅助索引的创建，InnoDB存储引擎会对创建索引的表加一个S锁。在创建的过程中，不需要重建表，因此速度较之前提高很多。由于加了S锁，创建过程中，可以对表进行读操作，不能进行写操作。删除索引的操作就更简单了。InnoDB存储引擎内部只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引即可。

**FIC方式只限定于辅助索引，对于主键的创建和删除同样需要重建一张表**。

## Online DDL

MySQL 5.6版本开始支持online DDL操作。以下几类操作都可以通过在线方式进行操作：

1. 辅助索引的创建与删除
2. 改变自增长值
3. 添加或删除外键约束
4. 列的重命名

InnoDB存储引擎实现online DDL的原理是在执行创建或删除操作的同时，将insert、update、delete这类DML操作日志写入到一个缓存中，待完成索引的创建后再将重做日志应用到表上，以此达到数据的一致性。这个缓存大小由参数`innodb_online_alter_log_max_size`控制。若用户更新的表比较大，并且在创建的过程中有大量的写事务，如遇到`innodb_online_alter_log_max_size`的空间不能存放日志，就会报错。

需要注意，由于online DDL在创建索引完成后再通过重做日志达到数据库的最终一致性，这意味着在索引创建过程中，SQL优化器不会选择正在创建中的索引。

cardinality

可以使用命令`show index`查看表中的索引信息





- Table：表的名称
- Non_unique：索引是否唯一，如果可以，则为1的，否则，为0
- Key_name：索引的名称
- Seq_in_index：索引中的列序列号，从1开始
- Column_name：列名称
- Collation：列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）
- Cardinality：索引中唯一值的估计数量。通过运行`ANALYZE TABLE`可以更新
- Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL
- Packed：关键字如何被压缩。如果没有被压缩，则为NULL
- Null：如果列含有NULL，则含有YES。如果没有，则该列含有NO
- Index_type：索引类型，InnoDB只会是BTREE
-  Comment ：注释

Cardinality值非常关键，表示索引中不重复记录数量的预估值，优化器会根据这个值来判断是否使用这个索引。在实际应用中，Cardinality应该尽可能接近数据行的总数，如果远小于数据行总数，那么就需要考虑是否还有必要创建这个索引。

如果每次索引在发生更改就对Cardinality进行更新，将会给数据库带来很大的负担。因此，数据库对于Cardinality的统计都是通过采样的方法来完成的。

InnoDB对更新Cardinality的策略为：

- 表中1/16的数据已发生过变化
- stat_modified_counter > 20亿。

第二种情况考虑的是，如果对表中某一行数据频繁地更新操作，表中有过改变的行记录总数并没有发生变化。故在InnoDB内部有一个stat_modified_counter 计数器，用来表示发生变化的次数。

在InnoDB中，Cardinality的采样方法为：随机选取8个叶子节点，计算其平均数据量，然后乘以叶子节点总数。

